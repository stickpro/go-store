// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: related_products.sql

package repository_products

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
	"github.com/stickpro/go-store/internal/constant"
)

const addRelatedProducts = `-- name: AddRelatedProducts :exec
INSERT INTO related_products (product_id, related_product_id)
SELECT $1::uuid, p.id
FROM products p
WHERE p.id = any($2::uuid[])
  AND p.id != $1::uuid
  AND NOT EXISTS (
    SELECT 1
    FROM related_products rp
    WHERE rp.product_id = $1
      AND rp.related_product_id = p.id
    )
`

type AddRelatedProductsParams struct {
	ProductID         uuid.UUID   `db:"product_id" json:"product_id"`
	RelatedProductIds []uuid.UUID `db:"related_product_ids" json:"related_product_ids"`
}

func (q *Queries) AddRelatedProducts(ctx context.Context, arg AddRelatedProductsParams) error {
	_, err := q.db.Exec(ctx, addRelatedProducts, arg.ProductID, arg.RelatedProductIds)
	return err
}

const deleteRelatedProducts = `-- name: DeleteRelatedProducts :exec
DELETE FROM related_products
WHERE product_id = $1
`

func (q *Queries) DeleteRelatedProducts(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRelatedProducts, productID)
	return err
}

const deleteSpecificRelatedProducts = `-- name: DeleteSpecificRelatedProducts :exec
DELETE FROM related_products
WHERE product_id = $1
  AND related_product_id = any($2::uuid[])
`

type DeleteSpecificRelatedProductsParams struct {
	ProductID uuid.UUID   `db:"product_id" json:"product_id"`
	Column2   []uuid.UUID `db:"column_2" json:"column_2"`
}

func (q *Queries) DeleteSpecificRelatedProducts(ctx context.Context, arg DeleteSpecificRelatedProductsParams) error {
	_, err := q.db.Exec(ctx, deleteSpecificRelatedProducts, arg.ProductID, arg.Column2)
	return err
}

const getRelatedProductsByProductID = `-- name: GetRelatedProductsByProductID :many
SELECT p.id,
       p.name,
       p.slug,
       p.model,
       p.price,
       p.image,
       p.is_enable,
       p.stock_status
FROM related_products rp
         JOIN products p ON rp.related_product_id = p.id
WHERE rp.product_id = $1
  AND p.is_enable = true
ORDER BY p.name
`

type GetRelatedProductsByProductIDRow struct {
	ID          uuid.UUID            `db:"id" json:"id"`
	Name        string               `db:"name" json:"name"`
	Slug        string               `db:"slug" json:"slug"`
	Model       string               `db:"model" json:"model"`
	Price       decimal.Decimal      `db:"price" json:"price"`
	Image       pgtype.Text          `db:"image" json:"image"`
	IsEnable    bool                 `db:"is_enable" json:"is_enable"`
	StockStatus constant.StockStatus `db:"stock_status" json:"stock_status"`
}

func (q *Queries) GetRelatedProductsByProductID(ctx context.Context, productID uuid.UUID) ([]*GetRelatedProductsByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getRelatedProductsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRelatedProductsByProductIDRow{}
	for rows.Next() {
		var i GetRelatedProductsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Model,
			&i.Price,
			&i.Image,
			&i.IsEnable,
			&i.StockStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelatedProductsBySlug = `-- name: GetRelatedProductsBySlug :many
SELECT p.id,
       p.name,
       p.slug,
       p.model,
       p.price,
       p.image,
       p.is_enable,
       p.stock_status
FROM related_products rp
         JOIN products p ON rp.related_product_id = p.id
WHERE rp.product_id = (SELECT id FROM p WHERE slug = $1)
  AND p.is_enable = true
ORDER BY p.name
`

type GetRelatedProductsBySlugRow struct {
	ID          uuid.UUID            `db:"id" json:"id"`
	Name        string               `db:"name" json:"name"`
	Slug        string               `db:"slug" json:"slug"`
	Model       string               `db:"model" json:"model"`
	Price       decimal.Decimal      `db:"price" json:"price"`
	Image       pgtype.Text          `db:"image" json:"image"`
	IsEnable    bool                 `db:"is_enable" json:"is_enable"`
	StockStatus constant.StockStatus `db:"stock_status" json:"stock_status"`
}

func (q *Queries) GetRelatedProductsBySlug(ctx context.Context, slug string) ([]*GetRelatedProductsBySlugRow, error) {
	rows, err := q.db.Query(ctx, getRelatedProductsBySlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRelatedProductsBySlugRow{}
	for rows.Next() {
		var i GetRelatedProductsBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Model,
			&i.Price,
			&i.Image,
			&i.IsEnable,
			&i.StockStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
