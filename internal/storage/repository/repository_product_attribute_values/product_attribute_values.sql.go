// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_attribute_values.sql

package repository_product_attribute_values

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const add = `-- name: Add :exec
INSERT INTO product_attribute_values (
    product_id,
    attribute_value_id,
    created_at
) VALUES (
    $1, $2, now()
)
ON CONFLICT (product_id, attribute_value_id) DO NOTHING
`

type AddParams struct {
	ProductID        uuid.UUID `db:"product_id" json:"product_id"`
	AttributeValueID uuid.UUID `db:"attribute_value_id" json:"attribute_value_id"`
}

func (q *Queries) Add(ctx context.Context, arg AddParams) error {
	_, err := q.db.Exec(ctx, add, arg.ProductID, arg.AttributeValueID)
	return err
}

const addBatch = `-- name: AddBatch :exec
INSERT INTO product_attribute_values (product_id, attribute_value_id, created_at)
SELECT $1, unnest($2::uuid[]), now()
ON CONFLICT (product_id, attribute_value_id) DO NOTHING
`

type AddBatchParams struct {
	ProductID        uuid.UUID   `db:"product_id" json:"product_id"`
	AttributeValueID []uuid.UUID `db:"attribute_value_id" json:"attribute_value_id"`
}

func (q *Queries) AddBatch(ctx context.Context, arg AddBatchParams) error {
	_, err := q.db.Exec(ctx, addBatch, arg.ProductID, arg.AttributeValueID)
	return err
}

const getByProductID = `-- name: GetByProductID :many
SELECT
    pav.product_id,
    pav.attribute_value_id,
    pav.created_at,
    a.id as attribute_id,
    a.name as attribute_name,
    a.slug as attribute_slug,
    a.type as attribute_type,
    a.unit as attribute_unit,
    a.is_filterable,
    a.is_visible,
    a.sort_order as attribute_sort_order,
    av.value as attribute_value,
    av.value_normalized,
    av.value_numeric,
    av.display_order as value_display_order,
    ag.id as group_id,
    ag.name as group_name,
    ag.slug as group_slug
FROM product_attribute_values pav
INNER JOIN attribute_values av ON pav.attribute_value_id = av.id
INNER JOIN attributes a ON av.attribute_id = a.id
INNER JOIN attribute_groups ag ON a.attribute_group_id = ag.id
WHERE pav.product_id = $1 AND a.is_visible = true AND av.is_active = true
ORDER BY ag.name ASC, a.sort_order ASC, av.display_order ASC
`

type GetByProductIDRow struct {
	ProductID          uuid.UUID           `db:"product_id" json:"product_id"`
	AttributeValueID   uuid.UUID           `db:"attribute_value_id" json:"attribute_value_id"`
	CreatedAt          pgtype.Timestamp    `db:"created_at" json:"created_at"`
	AttributeID        uuid.UUID           `db:"attribute_id" json:"attribute_id"`
	AttributeName      string              `db:"attribute_name" json:"attribute_name"`
	AttributeSlug      string              `db:"attribute_slug" json:"attribute_slug"`
	AttributeType      string              `db:"attribute_type" json:"attribute_type"`
	AttributeUnit      pgtype.Text         `db:"attribute_unit" json:"attribute_unit"`
	IsFilterable       pgtype.Bool         `db:"is_filterable" json:"is_filterable"`
	IsVisible          pgtype.Bool         `db:"is_visible" json:"is_visible"`
	AttributeSortOrder pgtype.Int4         `db:"attribute_sort_order" json:"attribute_sort_order"`
	AttributeValue     string              `db:"attribute_value" json:"attribute_value"`
	ValueNormalized    pgtype.Text         `db:"value_normalized" json:"value_normalized"`
	ValueNumeric       decimal.NullDecimal `db:"value_numeric" json:"value_numeric"`
	ValueDisplayOrder  pgtype.Int4         `db:"value_display_order" json:"value_display_order"`
	GroupID            uuid.UUID           `db:"group_id" json:"group_id"`
	GroupName          string              `db:"group_name" json:"group_name"`
	GroupSlug          string              `db:"group_slug" json:"group_slug"`
}

func (q *Queries) GetByProductID(ctx context.Context, productID uuid.UUID) ([]*GetByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetByProductIDRow{}
	for rows.Next() {
		var i GetByProductIDRow
		if err := rows.Scan(
			&i.ProductID,
			&i.AttributeValueID,
			&i.CreatedAt,
			&i.AttributeID,
			&i.AttributeName,
			&i.AttributeSlug,
			&i.AttributeType,
			&i.AttributeUnit,
			&i.IsFilterable,
			&i.IsVisible,
			&i.AttributeSortOrder,
			&i.AttributeValue,
			&i.ValueNormalized,
			&i.ValueNumeric,
			&i.ValueDisplayOrder,
			&i.GroupID,
			&i.GroupName,
			&i.GroupSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFiltersForCategory = `-- name: GetFiltersForCategory :many
SELECT
    a.id as attribute_id,
    a.slug as attribute_slug,
    a.name as attribute_name,
    a.type as attribute_type,
    a.unit as attribute_unit,
    a.sort_order as attribute_sort_order,
    ag.id as group_id,
    ag.name as group_name,
    ag.slug as group_slug,
    av.id as value_id,
    av.value as value,
    av.value_normalized,
    av.value_numeric,
    av.display_order as value_display_order,
    COUNT(DISTINCT p.id) as product_count
FROM products p
INNER JOIN product_attribute_values pav ON p.id = pav.product_id
INNER JOIN attribute_values av ON pav.attribute_value_id = av.id
INNER JOIN attributes a ON av.attribute_id = a.id
INNER JOIN attribute_groups ag ON a.attribute_group_id = ag.id
WHERE
    p.category_id = $1
    AND p.is_enable = true
    AND a.is_filterable = true
    AND av.is_active = true
GROUP BY
    a.id, a.slug, a.name, a.type, a.unit, a.sort_order,
    ag.id, ag.name, ag.slug,
    av.id, av.value, av.value_normalized, av.value_numeric, av.display_order
ORDER BY
    ag.name ASC,
    a.sort_order ASC,
    a.name ASC,
    av.display_order ASC,
    av.value ASC
`

type GetFiltersForCategoryRow struct {
	AttributeID        uuid.UUID           `db:"attribute_id" json:"attribute_id"`
	AttributeSlug      string              `db:"attribute_slug" json:"attribute_slug"`
	AttributeName      string              `db:"attribute_name" json:"attribute_name"`
	AttributeType      string              `db:"attribute_type" json:"attribute_type"`
	AttributeUnit      pgtype.Text         `db:"attribute_unit" json:"attribute_unit"`
	AttributeSortOrder pgtype.Int4         `db:"attribute_sort_order" json:"attribute_sort_order"`
	GroupID            uuid.UUID           `db:"group_id" json:"group_id"`
	GroupName          string              `db:"group_name" json:"group_name"`
	GroupSlug          string              `db:"group_slug" json:"group_slug"`
	ValueID            uuid.UUID           `db:"value_id" json:"value_id"`
	Value              string              `db:"value" json:"value"`
	ValueNormalized    pgtype.Text         `db:"value_normalized" json:"value_normalized"`
	ValueNumeric       decimal.NullDecimal `db:"value_numeric" json:"value_numeric"`
	ValueDisplayOrder  pgtype.Int4         `db:"value_display_order" json:"value_display_order"`
	ProductCount       int64               `db:"product_count" json:"product_count"`
}

func (q *Queries) GetFiltersForCategory(ctx context.Context, categoryID uuid.NullUUID) ([]*GetFiltersForCategoryRow, error) {
	rows, err := q.db.Query(ctx, getFiltersForCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFiltersForCategoryRow{}
	for rows.Next() {
		var i GetFiltersForCategoryRow
		if err := rows.Scan(
			&i.AttributeID,
			&i.AttributeSlug,
			&i.AttributeName,
			&i.AttributeType,
			&i.AttributeUnit,
			&i.AttributeSortOrder,
			&i.GroupID,
			&i.GroupName,
			&i.GroupSlug,
			&i.ValueID,
			&i.Value,
			&i.ValueNormalized,
			&i.ValueNumeric,
			&i.ValueDisplayOrder,
			&i.ProductCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const remove = `-- name: Remove :exec
DELETE FROM product_attribute_values
WHERE product_id = $1 AND attribute_value_id = $2
`

type RemoveParams struct {
	ProductID        uuid.UUID `db:"product_id" json:"product_id"`
	AttributeValueID uuid.UUID `db:"attribute_value_id" json:"attribute_value_id"`
}

func (q *Queries) Remove(ctx context.Context, arg RemoveParams) error {
	_, err := q.db.Exec(ctx, remove, arg.ProductID, arg.AttributeValueID)
	return err
}

const removeAll = `-- name: RemoveAll :exec
DELETE FROM product_attribute_values
WHERE product_id = $1
`

func (q *Queries) RemoveAll(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAll, productID)
	return err
}
