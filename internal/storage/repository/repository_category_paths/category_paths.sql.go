// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: category_paths.sql

package repository_category_paths

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCategoryPaths = `-- name: DeleteCategoryPaths :exec
DELETE FROM category_paths
WHERE descendant_id IN (
    SELECT cp1.descendant_id
    FROM category_paths cp1
    WHERE cp1.ancestor_id = $1
)
AND ancestor_id IN (
    SELECT cp2.ancestor_id
    FROM category_paths cp2
    WHERE cp2.descendant_id = $1
    AND cp2.depth > 0
)
`

func (q *Queries) DeleteCategoryPaths(ctx context.Context, ancestorID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategoryPaths, ancestorID)
	return err
}

const getAllAncestors = `-- name: GetAllAncestors :many
SELECT
    c.id,
    c.name,
    c.slug,
    cp.depth
FROM category_paths cp
JOIN categories c ON c.id = cp.ancestor_id
WHERE cp.descendant_id = $1
ORDER BY cp.depth DESC
`

type GetAllAncestorsRow struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Name  string    `db:"name" json:"name"`
	Slug  string    `db:"slug" json:"slug"`
	Depth int32     `db:"depth" json:"depth"`
}

func (q *Queries) GetAllAncestors(ctx context.Context, descendantID uuid.UUID) ([]*GetAllAncestorsRow, error) {
	rows, err := q.db.Query(ctx, getAllAncestors, descendantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllAncestorsRow{}
	for rows.Next() {
		var i GetAllAncestorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDescendants = `-- name: GetAllDescendants :many
SELECT
    c.id,
    c.parent_id,
    c.name,
    c.slug,
    cp.depth
FROM category_paths cp
JOIN categories c ON c.id = cp.descendant_id
WHERE cp.ancestor_id = $1
ORDER BY cp.depth ASC, c.name ASC
`

type GetAllDescendantsRow struct {
	ID       uuid.UUID     `db:"id" json:"id"`
	ParentID uuid.NullUUID `db:"parent_id" json:"parent_id"`
	Name     string        `db:"name" json:"name"`
	Slug     string        `db:"slug" json:"slug"`
	Depth    int32         `db:"depth" json:"depth"`
}

func (q *Queries) GetAllDescendants(ctx context.Context, ancestorID uuid.UUID) ([]*GetAllDescendantsRow, error) {
	rows, err := q.db.Query(ctx, getAllDescendants, ancestorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllDescendantsRow{}
	for rows.Next() {
		var i GetAllDescendantsRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.Slug,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBreadcrumbsByCategoryID = `-- name: GetBreadcrumbsByCategoryID :many
SELECT
    c.id,
    c.name,
    c.slug,
    c.meta_title,
    c.meta_h1,
    cp.depth
FROM category_paths cp
JOIN categories c ON c.id = cp.ancestor_id
WHERE cp.descendant_id = $1
ORDER BY cp.depth ASC
`

type GetBreadcrumbsByCategoryIDRow struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	Name      string      `db:"name" json:"name"`
	Slug      string      `db:"slug" json:"slug"`
	MetaTitle pgtype.Text `db:"meta_title" json:"meta_title"`
	MetaH1    pgtype.Text `db:"meta_h1" json:"meta_h1"`
	Depth     int32       `db:"depth" json:"depth"`
}

func (q *Queries) GetBreadcrumbsByCategoryID(ctx context.Context, descendantID uuid.UUID) ([]*GetBreadcrumbsByCategoryIDRow, error) {
	rows, err := q.db.Query(ctx, getBreadcrumbsByCategoryID, descendantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBreadcrumbsByCategoryIDRow{}
	for rows.Next() {
		var i GetBreadcrumbsByCategoryIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaH1,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBreadcrumbsByCategorySlug = `-- name: GetBreadcrumbsByCategorySlug :many
SELECT
    c.id,
    c.name,
    c.slug,
    c.meta_title,
    c.meta_h1,
    cp.depth
FROM categories target_cat
JOIN category_paths cp ON cp.descendant_id = target_cat.id
JOIN categories c ON c.id = cp.ancestor_id
WHERE target_cat.slug = $1
ORDER BY cp.depth ASC
`

type GetBreadcrumbsByCategorySlugRow struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	Name      string      `db:"name" json:"name"`
	Slug      string      `db:"slug" json:"slug"`
	MetaTitle pgtype.Text `db:"meta_title" json:"meta_title"`
	MetaH1    pgtype.Text `db:"meta_h1" json:"meta_h1"`
	Depth     int32       `db:"depth" json:"depth"`
}

func (q *Queries) GetBreadcrumbsByCategorySlug(ctx context.Context, slug string) ([]*GetBreadcrumbsByCategorySlugRow, error) {
	rows, err := q.db.Query(ctx, getBreadcrumbsByCategorySlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBreadcrumbsByCategorySlugRow{}
	for rows.Next() {
		var i GetBreadcrumbsByCategorySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaH1,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBreadcrumbsByProductSlug = `-- name: GetBreadcrumbsByProductSlug :many
SELECT
    c.id,
    c.name,
    c.slug,
    c.meta_title,
    c.meta_h1,
    cp.depth
FROM products p
JOIN categories c_product ON p.category_id = c_product.id
JOIN category_paths cp ON cp.descendant_id = c_product.id
JOIN categories c ON c.id = cp.ancestor_id
WHERE p.slug = $1
ORDER BY cp.depth ASC
`

type GetBreadcrumbsByProductSlugRow struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	Name      string      `db:"name" json:"name"`
	Slug      string      `db:"slug" json:"slug"`
	MetaTitle pgtype.Text `db:"meta_title" json:"meta_title"`
	MetaH1    pgtype.Text `db:"meta_h1" json:"meta_h1"`
	Depth     int32       `db:"depth" json:"depth"`
}

func (q *Queries) GetBreadcrumbsByProductSlug(ctx context.Context, slug string) ([]*GetBreadcrumbsByProductSlugRow, error) {
	rows, err := q.db.Query(ctx, getBreadcrumbsByProductSlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBreadcrumbsByProductSlugRow{}
	for rows.Next() {
		var i GetBreadcrumbsByProductSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.MetaTitle,
			&i.MetaH1,
			&i.Depth,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryDepth = `-- name: GetCategoryDepth :one
SELECT COALESCE(MAX(depth), 0) as depth
FROM category_paths
WHERE descendant_id = $1
`

func (q *Queries) GetCategoryDepth(ctx context.Context, descendantID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getCategoryDepth, descendantID)
	var depth interface{}
	err := row.Scan(&depth)
	return depth, err
}

const getCategoryPathsBatch = `-- name: GetCategoryPathsBatch :many
SELECT
    cp.ancestor_id,
    cp.descendant_id,
    cp.depth,
    c.name as descendant_name,
    c.slug as descendant_slug
FROM category_paths cp
JOIN categories c ON c.id = cp.descendant_id
WHERE cp.descendant_id = ANY($1::uuid[])
ORDER BY cp.descendant_id, cp.depth ASC
`

type GetCategoryPathsBatchRow struct {
	AncestorID     uuid.UUID `db:"ancestor_id" json:"ancestor_id"`
	DescendantID   uuid.UUID `db:"descendant_id" json:"descendant_id"`
	Depth          int32     `db:"depth" json:"depth"`
	DescendantName string    `db:"descendant_name" json:"descendant_name"`
	DescendantSlug string    `db:"descendant_slug" json:"descendant_slug"`
}

func (q *Queries) GetCategoryPathsBatch(ctx context.Context, dollar_1 []uuid.UUID) ([]*GetCategoryPathsBatchRow, error) {
	rows, err := q.db.Query(ctx, getCategoryPathsBatch, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCategoryPathsBatchRow{}
	for rows.Next() {
		var i GetCategoryPathsBatchRow
		if err := rows.Scan(
			&i.AncestorID,
			&i.DescendantID,
			&i.Depth,
			&i.DescendantName,
			&i.DescendantSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectChildren = `-- name: GetDirectChildren :many
SELECT
    c.id,
    c.parent_id,
    c.name,
    c.slug,
    c.is_enable
FROM category_paths cp
JOIN categories c ON c.id = cp.descendant_id
WHERE cp.ancestor_id = $1
  AND cp.depth = 1
ORDER BY c.name ASC
`

type GetDirectChildrenRow struct {
	ID       uuid.UUID     `db:"id" json:"id"`
	ParentID uuid.NullUUID `db:"parent_id" json:"parent_id"`
	Name     string        `db:"name" json:"name"`
	Slug     string        `db:"slug" json:"slug"`
	IsEnable bool          `db:"is_enable" json:"is_enable"`
}

func (q *Queries) GetDirectChildren(ctx context.Context, ancestorID uuid.UUID) ([]*GetDirectChildrenRow, error) {
	rows, err := q.db.Query(ctx, getDirectChildren, ancestorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetDirectChildrenRow{}
	for rows.Next() {
		var i GetDirectChildrenRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.Slug,
			&i.IsEnable,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCategoryPath = `-- name: InsertCategoryPath :exec
INSERT INTO category_paths (ancestor_id, descendant_id, depth)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type InsertCategoryPathParams struct {
	AncestorID   uuid.UUID `db:"ancestor_id" json:"ancestor_id"`
	DescendantID uuid.UUID `db:"descendant_id" json:"descendant_id"`
	Depth        int32     `db:"depth" json:"depth"`
}

func (q *Queries) InsertCategoryPath(ctx context.Context, arg InsertCategoryPathParams) error {
	_, err := q.db.Exec(ctx, insertCategoryPath, arg.AncestorID, arg.DescendantID, arg.Depth)
	return err
}

const isCategoryDescendantOf = `-- name: IsCategoryDescendantOf :one
SELECT EXISTS(
    SELECT 1
    FROM category_paths
    WHERE ancestor_id = $1
      AND descendant_id = $2
      AND depth > 0
) as is_descendant
`

type IsCategoryDescendantOfParams struct {
	AncestorID   uuid.UUID `db:"ancestor_id" json:"ancestor_id"`
	DescendantID uuid.UUID `db:"descendant_id" json:"descendant_id"`
}

func (q *Queries) IsCategoryDescendantOf(ctx context.Context, arg IsCategoryDescendantOfParams) (bool, error) {
	row := q.db.QueryRow(ctx, isCategoryDescendantOf, arg.AncestorID, arg.DescendantID)
	var is_descendant bool
	err := row.Scan(&is_descendant)
	return is_descendant, err
}
