// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attribute_values.sql

package repository_attribute_values

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
	"github.com/stickpro/go-store/internal/models"
)

const create = `-- name: Create :one
INSERT INTO attribute_values (
    attribute_id,
    value,
    value_normalized,
    value_numeric,
    display_order,
    is_active,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, now()
) RETURNING id, attribute_id, value, value_normalized, value_numeric, display_order, is_active, created_at, updated_at
`

type CreateParams struct {
	AttributeID     uuid.UUID           `db:"attribute_id" json:"attribute_id"`
	Value           string              `db:"value" json:"value"`
	ValueNormalized pgtype.Text         `db:"value_normalized" json:"value_normalized"`
	ValueNumeric    decimal.NullDecimal `db:"value_numeric" json:"value_numeric"`
	DisplayOrder    pgtype.Int4         `db:"display_order" json:"display_order"`
	IsActive        pgtype.Bool         `db:"is_active" json:"is_active"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*models.AttributeValue, error) {
	row := q.db.QueryRow(ctx, create,
		arg.AttributeID,
		arg.Value,
		arg.ValueNormalized,
		arg.ValueNumeric,
		arg.DisplayOrder,
		arg.IsActive,
	)
	var i models.AttributeValue
	err := row.Scan(
		&i.ID,
		&i.AttributeID,
		&i.Value,
		&i.ValueNormalized,
		&i.ValueNumeric,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const delete = `-- name: Delete :exec
DELETE FROM attribute_values
WHERE id = $1
`

func (q *Queries) Delete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delete, id)
	return err
}

const getAll = `-- name: GetAll :many
SELECT id, attribute_id, value, value_normalized, value_numeric, display_order, is_active, created_at, updated_at FROM attribute_values
WHERE attribute_id = $1
ORDER BY display_order ASC, value ASC
LIMIT $2 OFFSET $3
`

type GetAllParams struct {
	AttributeID uuid.UUID `db:"attribute_id" json:"attribute_id"`
	Limit       int32     `db:"limit" json:"limit"`
	Offset      int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetAll(ctx context.Context, arg GetAllParams) ([]*models.AttributeValue, error) {
	rows, err := q.db.Query(ctx, getAll, arg.AttributeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.AttributeValue{}
	for rows.Next() {
		var i models.AttributeValue
		if err := rows.Scan(
			&i.ID,
			&i.AttributeID,
			&i.Value,
			&i.ValueNormalized,
			&i.ValueNumeric,
			&i.DisplayOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByAttributeID = `-- name: GetByAttributeID :many
SELECT id, attribute_id, value, value_normalized, value_numeric, display_order, is_active, created_at, updated_at FROM attribute_values
WHERE attribute_id = $1 AND is_active = true
ORDER BY display_order ASC, value ASC
`

func (q *Queries) GetByAttributeID(ctx context.Context, attributeID uuid.UUID) ([]*models.AttributeValue, error) {
	rows, err := q.db.Query(ctx, getByAttributeID, attributeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.AttributeValue{}
	for rows.Next() {
		var i models.AttributeValue
		if err := rows.Scan(
			&i.ID,
			&i.AttributeID,
			&i.Value,
			&i.ValueNormalized,
			&i.ValueNumeric,
			&i.DisplayOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByID = `-- name: GetByID :one
SELECT id, attribute_id, value, value_normalized, value_numeric, display_order, is_active, created_at, updated_at FROM attribute_values
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetByID(ctx context.Context, id uuid.UUID) (*models.AttributeValue, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i models.AttributeValue
	err := row.Scan(
		&i.ID,
		&i.AttributeID,
		&i.Value,
		&i.ValueNormalized,
		&i.ValueNumeric,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getOrCreate = `-- name: GetOrCreate :one
INSERT INTO attribute_values (
    attribute_id,
    value,
    value_normalized,
    value_numeric,
    display_order,
    is_active,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, now()
)
ON CONFLICT (attribute_id, value)
DO UPDATE SET
    value_normalized = EXCLUDED.value_normalized,
    value_numeric = EXCLUDED.value_numeric,
    display_order = EXCLUDED.display_order,
    is_active = EXCLUDED.is_active,
    updated_at = now()
RETURNING id, attribute_id, value, value_normalized, value_numeric, display_order, is_active, created_at, updated_at
`

type GetOrCreateParams struct {
	AttributeID     uuid.UUID           `db:"attribute_id" json:"attribute_id"`
	Value           string              `db:"value" json:"value"`
	ValueNormalized pgtype.Text         `db:"value_normalized" json:"value_normalized"`
	ValueNumeric    decimal.NullDecimal `db:"value_numeric" json:"value_numeric"`
	DisplayOrder    pgtype.Int4         `db:"display_order" json:"display_order"`
	IsActive        pgtype.Bool         `db:"is_active" json:"is_active"`
}

func (q *Queries) GetOrCreate(ctx context.Context, arg GetOrCreateParams) (*models.AttributeValue, error) {
	row := q.db.QueryRow(ctx, getOrCreate,
		arg.AttributeID,
		arg.Value,
		arg.ValueNormalized,
		arg.ValueNumeric,
		arg.DisplayOrder,
		arg.IsActive,
	)
	var i models.AttributeValue
	err := row.Scan(
		&i.ID,
		&i.AttributeID,
		&i.Value,
		&i.ValueNormalized,
		&i.ValueNumeric,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getWithUsageCount = `-- name: GetWithUsageCount :many
SELECT
    av.id,
    av.attribute_id,
    av.value,
    av.value_normalized,
    av.value_numeric,
    av.display_order,
    av.is_active,
    av.created_at,
    av.updated_at,
    COUNT(DISTINCT pav.product_id) as usage_count
FROM attribute_values av
LEFT JOIN product_attribute_values pav ON av.id = pav.attribute_value_id
WHERE av.attribute_id = $1
GROUP BY av.id, av.attribute_id, av.value, av.value_normalized, av.value_numeric, av.display_order, av.is_active, av.created_at, av.updated_at
ORDER BY av.display_order ASC, av.value ASC
`

type GetWithUsageCountRow struct {
	ID              uuid.UUID           `db:"id" json:"id"`
	AttributeID     uuid.UUID           `db:"attribute_id" json:"attribute_id"`
	Value           string              `db:"value" json:"value"`
	ValueNormalized pgtype.Text         `db:"value_normalized" json:"value_normalized"`
	ValueNumeric    decimal.NullDecimal `db:"value_numeric" json:"value_numeric"`
	DisplayOrder    pgtype.Int4         `db:"display_order" json:"display_order"`
	IsActive        pgtype.Bool         `db:"is_active" json:"is_active"`
	CreatedAt       pgtype.Timestamp    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp    `db:"updated_at" json:"updated_at"`
	UsageCount      int64               `db:"usage_count" json:"usage_count"`
}

func (q *Queries) GetWithUsageCount(ctx context.Context, attributeID uuid.UUID) ([]*GetWithUsageCountRow, error) {
	rows, err := q.db.Query(ctx, getWithUsageCount, attributeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWithUsageCountRow{}
	for rows.Next() {
		var i GetWithUsageCountRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeID,
			&i.Value,
			&i.ValueNormalized,
			&i.ValueNumeric,
			&i.DisplayOrder,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update = `-- name: Update :one
UPDATE attribute_values
SET
    value = $1,
    value_normalized = $2,
    value_numeric = $3,
    display_order = $4,
    is_active = $5,
    updated_at = now()
WHERE id = $6
RETURNING id, attribute_id, value, value_normalized, value_numeric, display_order, is_active, created_at, updated_at
`

type UpdateParams struct {
	Value           string              `db:"value" json:"value"`
	ValueNormalized pgtype.Text         `db:"value_normalized" json:"value_normalized"`
	ValueNumeric    decimal.NullDecimal `db:"value_numeric" json:"value_numeric"`
	DisplayOrder    pgtype.Int4         `db:"display_order" json:"display_order"`
	IsActive        pgtype.Bool         `db:"is_active" json:"is_active"`
	ID              uuid.UUID           `db:"id" json:"id"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (*models.AttributeValue, error) {
	row := q.db.QueryRow(ctx, update,
		arg.Value,
		arg.ValueNormalized,
		arg.ValueNumeric,
		arg.DisplayOrder,
		arg.IsActive,
		arg.ID,
	)
	var i models.AttributeValue
	err := row.Scan(
		&i.ID,
		&i.AttributeID,
		&i.Value,
		&i.ValueNormalized,
		&i.ValueNumeric,
		&i.DisplayOrder,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
